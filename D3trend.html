<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCAG Violations - Trend Animation</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="js/gzip-utils.js"></script>
    <script src="js/loading.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr auto;
        }

        @media (max-width: 768px) {
            body {
                grid-template-rows: auto 1fr auto;
            }
        }

        .header {
            background: white;
            padding: 0.75rem 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            grid-row: 1;
        }

        .header h1 {
            font-size: 1.5rem;
            margin: 0;
        }

        .header-controls {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .header-controls label {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .header-controls select {
            padding: 0.4rem 0.6rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .header-controls button {
            padding: 0.4rem 1rem;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }

        .header-controls button:hover {
            background-color: #0D47A1;
        }

        .header-controls button.playing {
            background-color: #f44336;
        }

        .autocomplete-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .autocomplete-container input {
            padding: 0.4rem 0.6rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            min-width: 200px;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .autocomplete-item:hover {
            background-color: #f0f0f0;
        }

        .autocomplete-item.selected {
            background-color: #e3f2fd;
        }

        .autocomplete-item.no-results {
            cursor: default;
            color: #999;
            font-style: italic;
        }

        .autocomplete-item.no-results:hover {
            background-color: white;
        }

        .filter-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-container input {
            padding: 0.4rem 0.6rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            min-width: 200px;
        }

        .filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .filter-dropdown.show {
            display: block;
        }

        .filter-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .filter-item:hover {
            background-color: #f0f0f0;
        }

        .filter-item input[type="checkbox"] {
            cursor: pointer;
        }

        .filter-actions {
            padding: 0.5rem 0.75rem;
            border-top: 1px solid #eee;
            display: flex;
            gap: 0.5rem;
        }

        .filter-actions button {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
        }

        .filter-actions button:hover {
            background-color: #f0f0f0;
        }

        .filter-badge {
            display: inline-block;
            background-color: #2196F3;
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.75rem;
            margin-left: 0.25rem;
        }

        #chart {
            grid-row: 2;
            position: relative;
            width: 100%;
            height: 100%;
            background: white;
            overflow: hidden;
        }

        .axis path,
        .axis line {
            stroke: #aaa;
            stroke-width: 1;
        }

        .axis text {
            font-size: 11px;
            fill: #666;
        }

        .axis-label {
            font-size: 14px;
            font-weight: 500;
            fill: #333;
        }

        .year-label {
            font-size: 120px;
            fill: #eee;
            pointer-events: none;
            font-weight: bold;
        }

        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            border: 1px solid #999;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 200;
        }

        .tooltip strong {
            font-size: 13px;
            display: block;
            margin-bottom: 0.25rem;
            color: #333;
        }

        circle.country {
            stroke: #fff;
            stroke-width: 1.5;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        circle.country:hover {
            stroke-width: 2.5;
            stroke: #333;
        }

        .footer {
            grid-row: 3;
            background: white;
            padding: 0.5rem;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 2rem;
            align-items: start;
            z-index: 50;
        }

        @media (max-width: 1024px) {
            .footer {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        .legend {
            background: transparent;
            padding: 0;
            font-size: 12px;
        }

        .legend h3 {
            font-size: 13px;
            margin-bottom: 0.5rem;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 0.5rem;
            border: 1px solid #fff;
        }

        .info-box {
            background: transparent;
            padding: 0;
            font-size: 0.85rem;
        }

        .corner-label {
            position: absolute;
            font-size: 0.75rem;
            color: #999;
            font-weight: 500;
            pointer-events: none;
        }

        .corner-label.top-right {
            top: 10px;
            right: 10px;
        }

        .corner-label.bottom-left {
            bottom: 10px;
            left: 10px;
        }

        circle.country.tracked {
            fill: #000 !important;
            stroke: #fff;
            stroke-width: 3;
        }

        circle.trail {
            fill: #000 !important;
            stroke: #fff;
            stroke-width: 1;
            opacity: 0.5;
            pointer-events: none;
        }

        .tracking-layer {
            pointer-events: none;
        }

        .tracking-layer circle,
        .tracking-layer line {
            pointer-events: auto;
        }

        .tracking-info {
            background: rgba(255, 255, 255, 0.98);
            padding: 0.75rem;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 0.85rem;
            max-width: 500px;
            min-width: 350px;
            border: 2px solid #2196F3;
        }

        .tracking-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .tracking-section {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        @media (max-width: 1024px) {
            .tracking-info {
                grid-column: 1;
                min-width: auto;
            }
            
            .tracking-details {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
        }

        @media (max-width: 768px) {
            .tracking-info {
                max-width: 100%;
                font-size: 0.75rem;
                padding: 0.5rem;
            }
        }

        .tracking-info h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
            color: #2196F3;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tracking-info .close-btn {
            cursor: pointer;
            color: #666;
            font-size: 1.2rem;
            line-height: 1;
            padding: 0;
            background: none;
            border: none;
        }

        .tracking-info .close-btn:hover {
            color: #f44336;
        }

        .tracking-info.hidden {
            display: none;
        }

        .loading-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }

        .loading-message.hidden {
            display: none;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #2196F3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-progress {
            margin-top: 1rem;
            font-size: 0.9rem;
            color: #666;
        }

        .loading-bar-container {
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            border-radius: 4px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background-color: #2196F3;
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .loading-percentage {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2196F3;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>WCAG Violations - Trend Animation</h1>
        <button onclick="window.location.href='index.html'" style="padding: 0.4rem 1rem; background-color: #666; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; margin-right: 1rem;" onmouseover="this.style.backgroundColor='#444'" onmouseout="this.style.backgroundColor='#666'">← Tilbake til topplista</button>
        <div class="header-controls">
            <label for="date-range">Date Range:</label>
            <select id="date-range">
                <option value="7">Last 7 Days</option>
                <option value="14">Last 14 Days</option>
                <option value="30" selected>Last 30 Days</option>
                <option value="60">Last 60 Days</option>
                <option value="90">Last 90 Days</option>
                <option value="all">All Data</option>
            </select>
            <label for="y-axis">Y-Axis Metric:</label>
            <select id="y-axis">
                <option value="total">Total Violations</option>
                <option value="critical">Critical Severity</option>
                <option value="serious">Serious Severity</option>
                <option value="moderate">Moderate Severity</option>
                <option value="minor">Minor Severity</option>
                <optgroup label="WCAG Tags" id="tag-options">
                    <!-- Will be populated dynamically -->
                </optgroup>
            </select>
            <label for="speed">Speed:</label>
            <select id="speed">
                <option value="3000">Slow</option>
                <option value="1500" selected>Normal</option>
                <option value="750">Fast</option>
            </select>
            <div class="filter-container">
                <label for="project-filter">Filter Projects:<span class="filter-badge" id="filter-count">All</span></label>
                <input type="text" id="project-filter" placeholder="Search to filter..." autocomplete="off">
                <button id="select-all-filter" title="Select all projects">Select All</button>
                <button id="select-none-filter" title="Deselect all projects">Select None</button>
                <div class="filter-dropdown" id="filter-dropdown">
                    <div id="filter-items"></div>
                    <div class="filter-actions">
                        <button id="select-all">Select All</button>
                        <button id="deselect-all">Deselect All</button>
                    </div>
                </div>
            </div>
            <div class="autocomplete-container">
                <label for="project-search">Track Project:</label>
                <input type="text" id="project-search" placeholder="Search projects..." autocomplete="off">
                <div class="autocomplete-dropdown" id="autocomplete-dropdown"></div>
            </div>
            <button id="play-pause">▶ Play</button>
        </div>
    </div>

    <div id="chart"></div>

    <footer class="footer">
        <div class="legend" id="legend">
            <h3>Severity (Dominant)</h3>
            <div id="legend-items"></div>
        </div>

        <div class="info-box">
            <div><strong>X-Axis:</strong> Severity Score (weighted) <span style="font-size: 0.75rem; color: #888;">(← high severity | low severity →)</span></div>
            <div><strong>Y-Axis:</strong> <span id="y-axis-label">Total Violations</span> <span style="font-size: 0.75rem; color: #888;">(↓ fewer | more ↑)</span></div>
            <div><strong>Bubble Size:</strong> Total Violations</div>
            <div><strong>Bubble Color:</strong> Dominant Severity</div>
            <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #666;">
                <strong>Goal:</strong> Top-right corner (low severity, few violations)
            </div>
        </div>

            <div class="tracking-info hidden" id="trackingInfo">
            <h3>
                <span>Tracking: <span id="tracked-project-name"></span></span>
                <button class="close-btn" id="closeTracking" title="Stop tracking">×</button>
            </h3>
            <div id="tracked-project-details"></div>
        </div>
    </footer>

    <div class="loading-message" id="loadingMessage">
        <h2>Loading data...</h2>
        <div class="loading-spinner"></div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-percentage" id="loadingPercentage">0%</div>
        <div class="loading-progress" id="loadingProgress">Preparing to load reports...</div>
    </div>

    <script>
        // Global state
        let reportList = [];
        let availableDates = [];
        let allProjectsData = new Map();
        let allProjects = new Set();
        let allTags = new Set();
        let projectFirstValues = new Map(); // Store first report values per project
        let animationTimer = null;
        let isPlaying = false;
        let currentYearIndex = 0;
        let animationSpeed = 1500;
        let currentYAxisMetric = 'total';
        let trackedProject = null;
        let trailData = [];
        let autocompleteSelectedIndex = -1;
        let autocompleteFilteredProjects = [];
        let selectedProjects = new Set();
        let filterSearchTerm = '';
        let trackingLayer;

        // Chart dimensions
        const margin = { top: 40, right: 100, bottom: 60, left: 80 };
        const chartContainer = document.getElementById('chart');
        const width = chartContainer.clientWidth - margin.left - margin.right;
        const height = chartContainer.clientHeight - margin.top - margin.bottom;

        // Create SVG
        const svg = d3.select("#chart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

        // Add pattern definitions for trail bubbles
        const defs = svg.append("defs");
        
        // Create arrow markers for trail paths
        const severityColors = {
            'critical': '#d32f2f',
            'serious': '#f57c00',
            'moderate': '#fbc02d',
            'minor': '#689f38'
        };
        
        Object.entries(severityColors).forEach(([severity, color]) => {
            defs.append("marker")
                .attr("id", `arrow-${severity}`)
                .attr("viewBox", "0 0 10 10")
                .attr("refX", 8)
                .attr("refY", 5)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto-start-reverse")
                .append("path")
                .attr("d", "M 0 0 L 10 5 L 0 10 z")
                .attr("fill", "#000")
                .attr("opacity", 0.7);
        });
        
        // Create patterns for trail bubbles
        Object.entries(severityColors).forEach(([severity, color]) => {
            const pattern = defs.append("pattern")
                .attr("id", `trail-pattern-${severity}`)
                .attr("patternUnits", "userSpaceOnUse")
                .attr("width", 8)
                .attr("height", 8)
                .attr("patternTransform", "rotate(45)");
            
            pattern.append("rect")
                .attr("width", 8)
                .attr("height", 8)
                .attr("fill", color);
            
            pattern.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", 0)
                .attr("y2", 8)
                .attr("stroke", "white")
                .attr("stroke-width", 2);
        });

        const plotG = svg.append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        // Year label (large background text)
        const yearLabel = plotG.append("text")
            .attr("class", "year-label")
            .attr("x", width - 100)
            .attr("y", height - 50)
            .attr("text-anchor", "end");

        // Corner labels
        plotG.append("text")
            .attr("class", "corner-label top-right")
            .attr("x", width - 10)
            .attr("y", 10)
            .attr("text-anchor", "end")
            .text("✓ Best (Low severity, few violations)");

        plotG.append("text")
            .attr("class", "corner-label bottom-left")
            .attr("x", 10)
            .attr("y", height - 10)
            .attr("text-anchor", "start")
            .text("✗ Worst (High severity, most violations)");

        // Create separate layer for tracking elements (rendered on top - added last)
        trackingLayer = plotG.append("g")
            .attr("class", "tracking-layer");

        // Tooltip
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // Color scale for different violation severity
        const colorScale = d3.scaleOrdinal()
            .domain(['critical', 'serious', 'moderate', 'minor'])
            .range(['#d32f2f', '#f57c00', '#fbc02d', '#689f38']);

        // Initialize
        async function initialize() {
            try {
                showLoadingMessage(true);
                
                if (typeof fetchAndDecompressArchive !== 'function') {
                    throw new Error('Gzip utilities not loaded. Please ensure gzip-utils.js is loaded.');
                }

                // Fetch report list
                const response = await fetch('historical-data/report-list.json');
                if (!response.ok) {
                    throw new Error(`Failed to fetch report list: ${response.statusText}`);
                }
                
                reportList = await response.json();
                console.log(`Loaded ${reportList.length} reports from list`);

                // Extract available dates
                availableDates = extractDates(reportList);
                console.log(`Found ${availableDates.length} unique dates`);

                // Load data for the default date range
                await loadDataForDateRange(30);

                // Initialize selected projects (all by default)
                selectedProjects = new Set(allProjects);
                updateFilterBadge();

                // Populate Y-axis tag options
                populateYAxisOptions();

                // Create scales and axes
                createScalesAndAxes();

                // Create legend
                createLegend();

                // Start animation
                showLoadingMessage(false);
            } catch (error) {
                console.error('Initialization error:', error);
                alert(`Failed to initialize: ${error.message}`);
                showLoadingMessage(false);
            }
        }

        // Extract unique dates
        function extractDates(reports) {
            const dates = new Set();
            reports.forEach(filename => {
                if (filename.includes('-FAILED.json')) return;
                const match = filename.match(/\d{4}-\d{2}-\d{2}/);
                if (match) {
                    dates.add(match[0]);
                }
            });
            return Array.from(dates).sort();
        }

        // Parse report filename
        function parseReportFilename(filename) {
            if (filename.includes('-FAILED.json')) return null;
            
            const match = filename.match(/violations-(.+)-(\d{4}-\d{2}-\d{2})T(\d{2}-\d{2}-\d{2}_\d{3}Z)(?:-count-(\d+))?\.json$/);
            if (!match) return null;

            return {
                filename,
                project: match[1].replace(/_/g, ' '),
                date: match[2],
                time: match[3],
                violationCount: match[4] ? parseInt(match[4]) : null
            };
        }

        // Load data for date range
        async function loadDataForDateRange(days) {
            showLoadingMessage(true);
            allProjectsData.clear();
            allProjects.clear();

            let datesToLoad = [];
            if (days === 'all') {
                datesToLoad = [...availableDates];
            } else {
                const endDate = availableDates[availableDates.length - 1];
                const startDate = new Date(endDate);
                startDate.setDate(startDate.getDate() - days);
                datesToLoad = availableDates.filter(date => new Date(date) >= startDate);
            }

            console.log(`Loading data for ${datesToLoad.length} dates`);

            for (let i = 0; i < datesToLoad.length; i++) {
                const date = datesToLoad[i];
                const progress = Math.round(((i + 1) / datesToLoad.length) * 100);
                updateLoadingProgress(progress, `Loading ${i + 1} of ${datesToLoad.length} dates (${date})...`);
                
                try {
                    await loadDataForDate(date);
                } catch (error) {
                    console.error(`Failed to load data for ${date}:`, error);
                }
            }

            console.log(`Loaded data for ${allProjectsData.size} dates and ${allProjects.size} projects`);
            
            // Calculate first values for each project
            updateLoadingProgress(100, 'Finalizing data...');
            calculateProjectFirstValues();
            
            showLoadingMessage(false);
        }

        // Load data for specific date using gzip archives
        async function loadDataForDate(date) {
            const archiveUrl = `accessibility-reports/archives/reports_${date}.tar.gz`;
            
            try {
                const jsonFiles = await fetchAndDecompressArchive(archiveUrl);
                
                if (!allProjectsData.has(date)) {
                    allProjectsData.set(date, new Map());
                }
                
                const dateData = allProjectsData.get(date);

                Object.entries(jsonFiles).forEach(([filename, report]) => {
                    const parsed = parseReportFilename(filename);
                    if (!parsed) return;

                    const projectName = parsed.project;
                    allProjects.add(projectName);

                    if (!dateData.has(projectName) || parsed.time > dateData.get(projectName).time) {
                        // Calculate severity breakdown
                        const severityCount = {
                            critical: 0,
                            serious: 0,
                            moderate: 0,
                            minor: 0
                        };

                        // Extract tag information from violations
                        const tagCounts = {};

                        if (report.violations && Array.isArray(report.violations)) {
                            report.violations.forEach(violation => {
                                const impact = (violation.impact || 'moderate').toLowerCase();
                                if (severityCount.hasOwnProperty(impact)) {
                                    severityCount[impact] += violation.nodes?.length || 1;
                                }

                                // Count tags
                                if (violation.tags && Array.isArray(violation.tags)) {
                                    violation.tags.forEach(tag => {
                                        allTags.add(tag);
                                        const nodeCount = violation.nodes?.length || 1;
                                        tagCounts[tag] = (tagCounts[tag] || 0) + nodeCount;
                                    });
                                }
                            });
                        }

                        dateData.set(projectName, {
                            time: parsed.time,
                            violations: report.total_violations || 0,
                            severityCount: severityCount,
                            tagCounts: tagCounts,
                            details: report
                        });
                    }
                });

                console.log(`Loaded ${Object.keys(jsonFiles).length} reports from archive for ${date}`);
            } catch (error) {
                console.warn(`Archive not available for ${date}:`, error);
            }
        }

        // Populate Y-axis options with available tags
        function populateYAxisOptions() {
            const optgroup = document.getElementById('tag-options');
            optgroup.innerHTML = '';

            // Prioritize common WCAG tags
            const priorityTags = ['wcag2a', 'wcag2aa', 'wcag21a', 'wcag21aa', 'wcag22aa', 'wcag111', 'wcag412', 'wcag131'];
            
            const sortedTags = Array.from(allTags).sort((a, b) => {
                const aPriority = priorityTags.indexOf(a);
                const bPriority = priorityTags.indexOf(b);
                
                if (aPriority !== -1 && bPriority !== -1) return aPriority - bPriority;
                if (aPriority !== -1) return -1;
                if (bPriority !== -1) return 1;
                return a.localeCompare(b);
            });

            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = `tag:${tag}`;
                option.textContent = tag;
                optgroup.appendChild(option);
            });
        }

        // Get Y-axis value for a project based on selected metric
        function getYAxisValue(projectData, metric) {
            if (metric === 'total') {
                return projectData.violations;
            } else if (metric === 'critical' || metric === 'serious' || metric === 'moderate' || metric === 'minor') {
                return projectData.severityCount[metric] || 0;
            } else if (metric.startsWith('tag:')) {
                const tag = metric.substring(4);
                return projectData.tagCounts[tag] || 0;
            }
            return 0;
        }

        // Get label for Y-axis based on selected metric
        function getYAxisLabel(metric) {
            if (metric === 'total') {
                return 'Total Violations';
            } else if (metric === 'critical') {
                return 'Critical Violations';
            } else if (metric === 'serious') {
                return 'Serious Violations';
            } else if (metric === 'moderate') {
                return 'Moderate Violations';
            } else if (metric === 'minor') {
                return 'Minor Violations';
            } else if (metric.startsWith('tag:')) {
                const tag = metric.substring(4);
                return `${tag.toUpperCase()} Violations`;
            }
            return 'Violations';
        }

        // Calculate first report values for each project
        function calculateProjectFirstValues() {
            projectFirstValues.clear();
            
            const dates = Array.from(allProjectsData.keys()).sort();
            if (dates.length === 0) return;
            
            const firstDate = dates[0];
            const firstDateData = allProjectsData.get(firstDate);
            
            firstDateData.forEach((data, project) => {
                projectFirstValues.set(project, data.violations);
            });
            
            console.log(`Calculated first values for ${projectFirstValues.size} projects`);
        }

        // Calculate weighted severity score for a project
        function getSeverityScore(projectData) {
            const severities = projectData.severityCount;
            // Higher weights for more severe violations
            // Higher score = worse (more severe)
            const score = (severities.critical || 0) * 4 + 
                         (severities.serious || 0) * 3 + 
                         (severities.moderate || 0) * 2 + 
                         (severities.minor || 0) * 1;
            return score;
        }

        // Create scales and axes
        function createScalesAndAxes() {
            const dates = Array.from(allProjectsData.keys()).sort();
            if (dates.length === 0) return;

            // Build flat data array for domain calculation
            const allData = [];
            
            dates.forEach(date => {
                const dateData = allProjectsData.get(date);
                
                dateData.forEach((data, project) => {
                    const severityScore = getSeverityScore(data);
                    allData.push({
                        project: project,
                        date: date,
                        severityScore: severityScore,
                        yValue: getYAxisValue(data, currentYAxisMetric),
                        violations: data.violations
                    });
                });
            });

            // X scale: severity score (INVERTED - lower severity at right)
            // Right side = better (lower severity score)
            const xExtent = d3.extent(allData, d => d.severityScore);
            const xScale = d3.scaleLinear()
                .domain([xExtent[1] || 100, xExtent[0] || 0])
                .range([0, width])
                .nice();

            // Y scale: violations (INVERTED - fewer violations at top)
            // Top = fewer violations (better)
            const yScale = d3.scaleLinear()
                .domain([d3.max(allData, d => d.yValue) || 100, 0])
                .range([height, 0])
                .nice();

            // Size scale: total violations
            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(allData, d => d.violations) || 100])
                .range([5, 50]);

            // Store scales globally
            window.xScale = xScale;
            window.yScale = yScale;
            window.sizeScale = sizeScale;

            // Create axes
            const xAxis = d3.axisBottom(xScale).ticks(10);
            const yAxis = d3.axisLeft(yScale).ticks(10);

            plotG.append("g")
                .attr("class", "x axis")
                .attr("transform", `translate(0, ${height})`)
                .call(xAxis);

            plotG.append("text")
                .attr("class", "axis-label")
                .attr("x", width / 2)
                .attr("y", height + 45)
                .attr("text-anchor", "middle")
                .text("Severity Score (weighted: Critical×4, Serious×3, Moderate×2, Minor×1)");

            // Add diagonal reference line from bottom-left to top-right
            plotG.append("line")
                .attr("class", "diagonal-line")
                .style("stroke", "#ccc")
                .style("stroke-width", 2)
                .style("stroke-dasharray", "5,5")
                .style("opacity", 0.5)
                .attr("x1", 0)
                .attr("y1", height)
                .attr("x2", width)
                .attr("y2", 0);

            plotG.append("g")
                .attr("class", "y axis")
                .call(yAxis);

            plotG.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -60)
                .attr("text-anchor", "middle")
                .text(getYAxisLabel(currentYAxisMetric));

            // Ensure tracking layer is on top
            if (trackingLayer) {
                trackingLayer.remove();
            }
            trackingLayer = plotG.append("g")
                .attr("class", "tracking-layer");

            // Start with first frame
            updateChart(dates[0]);
        }

        // Update chart for a specific date
        function updateChart(date) {
            const dateData = allProjectsData.get(date);
            if (!dateData) return;

            // Prepare data for bubbles (filtered by selected projects)
            const bubbleData = [];
            dateData.forEach((data, project) => {
                // Skip if project is not selected
                if (!selectedProjects.has(project)) return;
                
                // Assign color based on dominant severity
                const severities = data.severityCount;
                let dominantSeverity = 'moderate';
                let maxCount = 0;
                Object.entries(severities).forEach(([severity, count]) => {
                    if (count > maxCount) {
                        maxCount = count;
                        dominantSeverity = severity;
                    }
                });

                const severityScore = getSeverityScore(data);
                const yValue = getYAxisValue(data, currentYAxisMetric);

                bubbleData.push({
                    project: project,
                    severityScore: severityScore,
                    violations: data.violations,
                    yValue: yValue,
                    severity: dominantSeverity,
                    severityBreakdown: data.severityCount,
                    tagCounts: data.tagCounts,
                    firstValue: projectFirstValues.get(project) || 0
                });
            });

            // Data join
            const circles = plotG.selectAll("circle.country")
                .data(bubbleData, d => d.project);

            // Exit
            circles.exit()
                .transition()
                .duration(500)
                .attr("r", 0)
                .remove();

            // Enter
            const enter = circles.enter()
                .append("circle")
                .attr("class", "country")
                .attr("cx", d => window.xScale(d.severityScore))
                .attr("cy", d => window.yScale(d.yValue))
                .attr("r", 0)
                .attr("fill", d => colorScale(d.severity))
                .attr("opacity", 0.7)
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("opacity", 1);
                    
                    // Build tooltip content dynamically
                    let tooltipContent = `<strong>${d.project}</strong>`;
                    tooltipContent += `<div>Total Violations: ${d.violations}</div>`;
                    tooltipContent += `<div>Severity Score: ${d.severityScore.toFixed(0)}</div>`;
                    
                    tooltipContent += `<div style="margin-top: 0.5rem;">Critical: ${d.severityBreakdown.critical}</div>`;
                    tooltipContent += `<div>Serious: ${d.severityBreakdown.serious}</div>`;
                    tooltipContent += `<div>Moderate: ${d.severityBreakdown.moderate}</div>`;
                    tooltipContent += `<div>Minor: ${d.severityBreakdown.minor}</div>`;
                    
                    // If viewing a specific tag, show its count
                    if (currentYAxisMetric.startsWith('tag:')) {
                        const tag = currentYAxisMetric.substring(4);
                        tooltipContent += `<div style="margin-top: 0.5rem; font-weight: bold;">${tag}: ${d.yValue}</div>`;
                    }
                    
                    tooltip
                        .style("opacity", 1)
                        .html(tooltipContent)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).attr("opacity", 0.7);
                    tooltip.style("opacity", 0);
                })
                .on("click", function(event, d) {
                    event.stopPropagation();
                    if (trackedProject === d.project) {
                        stopTracking();
                    } else {
                        startTracking(d.project);
                    }
                });

            // Enter + Update
            const merged = enter.merge(circles)
                .classed("tracked", d => d.project === trackedProject);
            
            // Move tracked bubble to tracking layer for higher z-index
            merged.each(function(d) {
                if (d.project === trackedProject) {
                    trackingLayer.node().appendChild(this);
                } else {
                    // Move back to main layer if no longer tracked
                    if (this.parentNode === trackingLayer.node()) {
                        plotG.node().insertBefore(this, trackingLayer.node());
                    }
                }
            });
            
            merged.transition()
                .duration(1000)
                .attr("cx", d => window.xScale(d.severityScore))
                .attr("cy", d => window.yScale(d.yValue))
                .attr("r", d => window.sizeScale(d.violations))
                .attr("fill", d => colorScale(d.severity));

            // Update trail if tracking
            if (trackedProject) {
                updateTrail();
                updateTrackingInfo(bubbleData.find(d => d.project === trackedProject));
            }

            // Update year label
            yearLabel.text(date);
        }

        // Create legend
        function createLegend() {
            const legendData = [
                { severity: 'critical', label: 'Critical' },
                { severity: 'serious', label: 'Serious' },
                { severity: 'moderate', label: 'Moderate' },
                { severity: 'minor', label: 'Minor' }
            ];

            const legendItems = d3.select('#legend-items');
            
            legendData.forEach(item => {
                const div = legendItems.append('div')
                    .attr('class', 'legend-item');
                
                div.append('div')
                    .attr('class', 'legend-color')
                    .style('background-color', colorScale(item.severity));
                
                div.append('span')
                    .text(item.label);
            });
        }

        // Tracking functions
        function startTracking(projectName) {
            trackedProject = projectName;
            trailData = [];
            
            // Remove tracked class from all circles
            plotG.selectAll("circle.country")
                .classed("tracked", d => d.project === trackedProject);
            
            // Show tracking info
            document.getElementById('tracked-project-name').textContent = projectName;
            document.getElementById('trackingInfo').classList.remove('hidden');
            
            // Update search input
            document.getElementById('project-search').value = projectName;
            
            // Hide tooltip when tracking
            tooltip.style("opacity", 0);
        }

        function stopTracking() {
            trackedProject = null;
            trailData = [];
            
            // Remove tracked class from all circles
            plotG.selectAll("circle.country").classed("tracked", false);
            
            // Remove trail circles and paths from tracking layer
            trackingLayer.selectAll("circle.trail").remove();
            trackingLayer.selectAll("line.trail-path").remove();
            
            // Hide tracking info
            document.getElementById('trackingInfo').classList.add('hidden');
            
            // Clear search input
            document.getElementById('project-search').value = '';
            document.getElementById('autocomplete-dropdown').classList.remove('show');
        }

        function updateTrail() {
            const dates = Array.from(allProjectsData.keys()).sort();
            const currentDate = dates[currentYearIndex];
            
            // Build trail data from start to current frame
            const newTrailData = [];
            for (let i = 0; i < currentYearIndex; i++) {
                const date = dates[i];
                const dateData = allProjectsData.get(date);
                if (dateData && dateData.has(trackedProject)) {
                    const data = dateData.get(trackedProject);
                    const severityScore = getSeverityScore(data);
                    const yValue = getYAxisValue(data, currentYAxisMetric);
                    
                    // Determine dominant severity
                    const severities = data.severityCount;
                    let dominantSeverity = 'moderate';
                    let maxCount = 0;
                    Object.entries(severities).forEach(([severity, count]) => {
                        if (count > maxCount) {
                            maxCount = count;
                            dominantSeverity = severity;
                        }
                    });
                    
                    newTrailData.push({
                        date: date,
                        severityScore: severityScore,
                        yValue: yValue,
                        violations: data.violations,
                        severity: dominantSeverity,
                        x: window.xScale(severityScore),
                        y: window.yScale(yValue)
                    });
                }
            }
            
            // Update path lines between trail points
            const pathData = [];
            for (let i = 0; i < newTrailData.length - 1; i++) {
                pathData.push({
                    x1: newTrailData[i].x,
                    y1: newTrailData[i].y,
                    x2: newTrailData[i + 1].x,
                    y2: newTrailData[i + 1].y,
                    severity: newTrailData[i + 1].severity
                });
            }
            
            // Draw path lines with arrows in tracking layer
            const paths = trackingLayer.selectAll("line.trail-path")
                .data(pathData, (d, i) => i);
            
            paths.exit().remove();
            
            const pathEnter = paths.enter()
                .append("line")
                .attr("class", "trail-path");
            
            pathEnter.merge(paths)
                .attr("x1", d => d.x1)
                .attr("y1", d => d.y1)
                .attr("x2", d => d.x2)
                .attr("y2", d => d.y2)
                .attr("stroke", "#000")
                .attr("stroke-width", 2)
                .attr("stroke-opacity", 0.5)
                .attr("marker-end", d => `url(#arrow-${d.severity})`);
            
            // Update trail circles in tracking layer
            const trails = trackingLayer.selectAll("circle.trail")
                .data(newTrailData, (d, i) => i);
            
            trails.exit().remove();
            
            const trailEnter = trails.enter()
                .append("circle")
                .attr("class", "trail");
            
            trailEnter.merge(trails)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => window.sizeScale(d.violations))
                .attr("fill", "#000");
        }

        function updateTrackingInfo(projectData) {
            if (!projectData) return;
            
            const dates = Array.from(allProjectsData.keys()).sort();
            const currentDate = dates[currentYearIndex];
            
            let infoHTML = `<div class="tracking-details">`;
            
            // Left container: General info
            infoHTML += `<div class="tracking-section">`;
            infoHTML += `<div><strong>Date:</strong> ${currentDate}</div>`;
            infoHTML += `<div><strong>Total Violations:</strong> ${projectData.violations}</div>`;
            infoHTML += `<div><strong>Severity Score:</strong> ${projectData.severityScore.toFixed(0)}</div>`;
            
            if (currentYAxisMetric.startsWith('tag:')) {
                const tag = currentYAxisMetric.substring(4);
                infoHTML += `<div style="margin-top: 0.5rem;"><strong>${tag}:</strong> ${projectData.yValue}</div>`;
            }
            
            infoHTML += `</div>`;
            
            // Right container: Severity breakdown
            infoHTML += `<div class="tracking-section">`;
            infoHTML += `<div><strong>Critical:</strong> ${projectData.severityBreakdown.critical}</div>`;
            infoHTML += `<div><strong>Serious:</strong> ${projectData.severityBreakdown.serious}</div>`;
            infoHTML += `<div><strong>Moderate:</strong> ${projectData.severityBreakdown.moderate}</div>`;
            infoHTML += `<div><strong>Minor:</strong> ${projectData.severityBreakdown.minor}</div>`;
            infoHTML += `</div>`;
            
            infoHTML += `</div>`;
            
            document.getElementById('tracked-project-details').innerHTML = infoHTML;
        }

        // Animation control
        function animate() {
            const dates = Array.from(allProjectsData.keys()).sort();
            if (dates.length === 0) return;

            updateChart(dates[currentYearIndex]);
            currentYearIndex = (currentYearIndex + 1) % dates.length;
            
            if (isPlaying) {
                animationTimer = setTimeout(animate, animationSpeed);
            }
        }

        function togglePlayPause() {
            isPlaying = !isPlaying;
            const button = document.getElementById('play-pause');
            
            if (isPlaying) {
                button.textContent = '⏸ Pause';
                button.classList.add('playing');
                animate();
            } else {
                button.textContent = '▶ Play';
                button.classList.remove('playing');
                if (animationTimer) {
                    clearTimeout(animationTimer);
                    animationTimer = null;
                }
            }
        }

        // Filter functions
        function updateFilterDropdown(searchTerm) {
            filterSearchTerm = searchTerm;
            const dropdownContainer = document.getElementById('filter-items');
            const projectsArray = Array.from(allProjects).sort();
            
            const lowerSearch = searchTerm.toLowerCase();
            const filteredProjects = searchTerm.trim() 
                ? projectsArray.filter(project => project.toLowerCase().includes(lowerSearch))
                : projectsArray;
            
            dropdownContainer.innerHTML = '';
            
            filteredProjects.forEach(project => {
                const item = document.createElement('div');
                item.className = 'filter-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = selectedProjects.has(project);
                checkbox.id = `filter-${project.replace(/\s/g, '-')}`;
                
                checkbox.addEventListener('change', function() {
                    if (this.checked) {
                        selectedProjects.add(project);
                    } else {
                        selectedProjects.delete(project);
                    }
                    updateFilterBadge();
                    refreshChart();
                });
                
                const label = document.createElement('label');
                label.textContent = project;
                label.style.cursor = 'pointer';
                label.htmlFor = checkbox.id;
                
                item.appendChild(checkbox);
                item.appendChild(label);
                dropdownContainer.appendChild(item);
            });
        }
        
        function updateFilterBadge() {
            const badge = document.getElementById('filter-count');
            if (selectedProjects.size === allProjects.size) {
                badge.textContent = 'All';
            } else {
                badge.textContent = selectedProjects.size;
            }
        }
        
        function selectAllProjects() {
            selectedProjects = new Set(allProjects);
            updateFilterDropdown(filterSearchTerm);
            updateFilterBadge();
            refreshChart();
        }
        
        function deselectAllProjects() {
            selectedProjects.clear();
            updateFilterDropdown(filterSearchTerm);
            updateFilterBadge();
            refreshChart();
        }
        
        function selectAllFilter() {
            // Clear search input
            document.getElementById('project-filter').value = '';
            filterSearchTerm = '';
            
            // Select all projects
            selectedProjects = new Set(allProjects);
            updateFilterDropdown('');
            updateFilterBadge();
            refreshChart();
            
            // Close dropdown
            document.getElementById('filter-dropdown').classList.remove('show');
        }
        
        function selectNoneFilter() {
            // Clear search input
            document.getElementById('project-filter').value = '';
            filterSearchTerm = '';
            
            // Deselect all projects
            selectedProjects.clear();
            updateFilterDropdown('');
            updateFilterBadge();
            refreshChart();
            
            // Close dropdown
            document.getElementById('filter-dropdown').classList.remove('show');
        }
        
        function refreshChart() {
            const dates = Array.from(allProjectsData.keys()).sort();
            if (dates.length > 0 && currentYearIndex < dates.length) {
                updateChart(dates[currentYearIndex]);
            }
        }

        // Autocomplete functions
        function updateAutocomplete(searchTerm) {
            const dropdown = document.getElementById('autocomplete-dropdown');
            const projectsArray = Array.from(allProjects).sort();
            
            if (!searchTerm.trim()) {
                dropdown.classList.remove('show');
                autocompleteFilteredProjects = [];
                autocompleteSelectedIndex = -1;
                return;
            }
            
            const lowerSearch = searchTerm.toLowerCase();
            autocompleteFilteredProjects = projectsArray.filter(project => 
                project.toLowerCase().includes(lowerSearch)
            );
            
            if (autocompleteFilteredProjects.length === 0) {
                dropdown.innerHTML = '<div class="autocomplete-item no-results">No projects found</div>';
                dropdown.classList.add('show');
                return;
            }
            
            dropdown.innerHTML = '';
            autocompleteFilteredProjects.forEach((project, index) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = project;
                item.addEventListener('click', () => selectProject(project));
                dropdown.appendChild(item);
            });
            
            dropdown.classList.add('show');
            autocompleteSelectedIndex = -1;
        }
        
        function selectProject(projectName) {
            const input = document.getElementById('project-search');
            input.value = projectName;
            document.getElementById('autocomplete-dropdown').classList.remove('show');
            startTracking(projectName);
        }
        
        function navigateAutocomplete(direction) {
            const dropdown = document.getElementById('autocomplete-dropdown');
            const items = dropdown.querySelectorAll('.autocomplete-item:not(.no-results)');
            
            if (items.length === 0) return;
            
            // Remove previous selection
            if (autocompleteSelectedIndex >= 0 && autocompleteSelectedIndex < items.length) {
                items[autocompleteSelectedIndex].classList.remove('selected');
            }
            
            // Update index
            if (direction === 'down') {
                autocompleteSelectedIndex = (autocompleteSelectedIndex + 1) % items.length;
            } else if (direction === 'up') {
                autocompleteSelectedIndex = autocompleteSelectedIndex <= 0 
                    ? items.length - 1 
                    : autocompleteSelectedIndex - 1;
            }
            
            // Add new selection
            items[autocompleteSelectedIndex].classList.add('selected');
            items[autocompleteSelectedIndex].scrollIntoView({ block: 'nearest' });
        }

        // Event listeners
        document.getElementById('play-pause').addEventListener('click', togglePlayPause);
        
        document.getElementById('closeTracking').addEventListener('click', stopTracking);
        
        // Project search autocomplete
        const projectSearchInput = document.getElementById('project-search');
        const autocompleteDropdown = document.getElementById('autocomplete-dropdown');
        
        projectSearchInput.addEventListener('input', function(e) {
            updateAutocomplete(e.target.value);
        });
        
        projectSearchInput.addEventListener('keydown', function(e) {
            const dropdown = document.getElementById('autocomplete-dropdown');
            
            if (!dropdown.classList.contains('show')) return;
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                navigateAutocomplete('down');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                navigateAutocomplete('up');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteSelectedIndex >= 0 && autocompleteSelectedIndex < autocompleteFilteredProjects.length) {
                    selectProject(autocompleteFilteredProjects[autocompleteSelectedIndex]);
                } else if (autocompleteFilteredProjects.length === 1) {
                    selectProject(autocompleteFilteredProjects[0]);
                }
            } else if (e.key === 'Escape') {
                dropdown.classList.remove('show');
                autocompleteSelectedIndex = -1;
            }
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.autocomplete-container')) {
                autocompleteDropdown.classList.remove('show');
                autocompleteSelectedIndex = -1;
            }
        });
        
        projectSearchInput.addEventListener('focus', function() {
            if (this.value.trim()) {
                updateAutocomplete(this.value);
            }
        });
        
        // Project filter
        const projectFilterInput = document.getElementById('project-filter');
        const filterDropdown = document.getElementById('filter-dropdown');
        
        projectFilterInput.addEventListener('input', function(e) {
            updateFilterDropdown(e.target.value);
        });
        
        projectFilterInput.addEventListener('focus', function() {
            filterDropdown.classList.add('show');
            updateFilterDropdown(this.value);
        });
        
        // Close filter dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.filter-container')) {
                filterDropdown.classList.remove('show');
            }
        });
        
        document.getElementById('select-all').addEventListener('click', function(e) {
            e.stopPropagation();
            selectAllProjects();
        });
        
        document.getElementById('deselect-all').addEventListener('click', function(e) {
            e.stopPropagation();
            deselectAllProjects();
        });
        
        document.getElementById('select-all-filter').addEventListener('click', function(e) {
            e.stopPropagation();
            selectAllFilter();
        });
        
        document.getElementById('select-none-filter').addEventListener('click', function(e) {
            e.stopPropagation();
            selectNoneFilter();
        });

        document.getElementById('speed').addEventListener('change', function() {
            animationSpeed = parseInt(this.value);
            if (isPlaying) {
                // Restart animation with new speed
                clearTimeout(animationTimer);
                animate();
            }
        });

        document.getElementById('y-axis').addEventListener('change', function() {
            currentYAxisMetric = this.value;
            
            // Update info box label
            document.getElementById('y-axis-label').textContent = getYAxisLabel(currentYAxisMetric);
            
            // Stop tracking
            stopTracking();
            
            // Stop animation if playing
            if (isPlaying) {
                togglePlayPause();
            }
            
            // Clear existing chart
            plotG.selectAll("*").remove();
            
            // Re-add corner labels
            plotG.append("text")
                .attr("class", "corner-label top-right")
                .attr("x", width - 10)
                .attr("y", 10)
                .attr("text-anchor", "end")
                .text("✓ Best (Low severity, few violations)");

            plotG.append("text")
                .attr("class", "corner-label bottom-left")
                .attr("x", 10)
                .attr("y", height - 10)
                .attr("text-anchor", "start")
                .text("✗ Worst (High severity, most violations)");
            
            // Re-add year label
            plotG.append("text")
                .attr("class", "year-label")
                .attr("x", width - 100)
                .attr("y", height - 50)
                .attr("text-anchor", "end");
            
            // Recreate chart with new Y-axis
            createScalesAndAxes();
            
            // Recreate tracking layer last (on top)
            trackingLayer = plotG.append("g")
                .attr("class", "tracking-layer");
            
            // Reset animation
            currentYearIndex = 0;
        });

        document.getElementById('date-range').addEventListener('change', async function() {
            const value = this.value;
            const days = value === 'all' ? 'all' : parseInt(value);
            
            // Stop tracking
            stopTracking();
            
            // Stop animation
            if (isPlaying) {
                togglePlayPause();
            }
            
            // Clear existing chart
            plotG.selectAll("*").remove();
            
            // Re-add corner labels
            plotG.append("text")
                .attr("class", "corner-label top-right")
                .attr("x", width - 10)
                .attr("y", 10)
                .attr("text-anchor", "end")
                .text("✓ Best (Low severity, few violations)");

            plotG.append("text")
                .attr("class", "corner-label bottom-left")
                .attr("x", 10)
                .attr("y", height - 10)
                .attr("text-anchor", "start")
                .text("✗ Worst (High severity, most violations)");
            
            // Re-add year label
            plotG.append("text")
                .attr("class", "year-label")
                .attr("x", width - 100)
                .attr("y", height - 50)
                .attr("text-anchor", "end");
            
            // Reload data
            await loadDataForDateRange(days);
            
            // Reset selected projects to all
            selectedProjects = new Set(allProjects);
            updateFilterBadge();
            updateFilterDropdown(filterSearchTerm);
            
            // Repopulate Y-axis options
            populateYAxisOptions();
            
            // Recalculate first values
            calculateProjectFirstValues();
            
            // Recreate chart
            createScalesAndAxes();
            
            // Recreate tracking layer last (on top)
            trackingLayer = plotG.append("g")
                .attr("class", "tracking-layer");
            
            // Reset animation
            currentYearIndex = 0;
        });

        // Helper functions
        function showLoadingMessage(show) {
            const loadingMsg = document.getElementById('loadingMessage');
            if (show) {
                loadingMsg.classList.remove('hidden');
                updateLoadingProgress(0, 'Preparing to load reports...');
            } else {
                loadingMsg.classList.add('hidden');
            }
        }

        function updateLoadingProgress(percentage, message) {
            const loadingBar = document.getElementById('loadingBar');
            const loadingPercentage = document.getElementById('loadingPercentage');
            const loadingProgress = document.getElementById('loadingProgress');
            
            if (loadingBar) {
                loadingBar.style.width = `${percentage}%`;
            }
            
            if (loadingPercentage) {
                loadingPercentage.textContent = `${percentage}%`;
            }
            
            if (loadingProgress && message) {
                loadingProgress.textContent = message;
            }
        }

        // Initialize on load
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
